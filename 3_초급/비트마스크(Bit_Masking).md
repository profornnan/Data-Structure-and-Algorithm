# 비트마스크(Bit Masking)

* 내부적으로 이진수를 사용하는 컴퓨터들은 이진법 관련 연산들을 아주 빨리 할 수 있다.
* 이와 같은 특성을 이용해 정수의 이진수 표현을 자료 구조로 쓰는 기법을 비트마스크(bitmask)라고 한다.



## 비트 마스크를 사용하는 코드의 장점

* 더 빠른 수행 시간
  * 비트마스크 연산은 O(1)에 구현되는 것이 많기 때문에, 적절히 사용할 경우 다른 자료 구조를 사용하는 것보다 훨씬 빨리 동작한다.
  * 비트마스크를 사용할 수 있다는 말은 원소의 수가 많지 않다는 뜻이기 때문에 엄청나게 큰 속도 향상을 기대할 수는 없지만, 이와 같은 연산을 굉장히 여러 번 수행해야 하는 경우에는 작은 최적화도 큰 속도 향상을 가져올 수 있다.
* 더 간결한 코드
  * 다양한 집합 연산들을 반복문 없이 한 줄에 쓸 수 있기 때문에 비트마스크를 적절히 사용하면 굉장히 짧은 코드를 작성할 수 있다.
* 더 작은 메모리 사용량
  * 비트마스크를 이용하는 코드들은 같은 데이터를 더 적은 메모리를 사용해 표현할 수 있다.
  * 더 적은 메모리를 사용한다는 말은 더 많은 데이터를 미리 계산해서 저장해 둘 수 있다는 뜻이다.
* 연관 배열을 배열로 대체
  * 불린 값 배열을 키로 갖는 연관 배열 객체 `map<vector<bool>, int>`를 사용하는 경우, 비트마스크를 써서 같은 정보를 정수 변수로 나타내면 단순한 배열 `int[]`를 사용해 같은 정보를 나타낼 수 있다.



## 용어 정의

* 컴퓨터는 모든 정수형 변수를 이진수로 표현한다. 이때 이진수의 한 자리를 비트(bit)라고 한다.
* 비트는 0 혹은 1의 값을 가질 수 있으며, 컴퓨터가 표현하는 모든 자료의 근간이 된다.
* 부호 없는 8비트 정수형이 가질 수 있는 최소값은 0, 최대값은 1111 1111<sub>2</sub> = 255 이다.
* 부호 없는 N비트 정수형 변수는 N자리의 이진수로 쓸 수 있다. 이때 각 비트가 표현하는 값은 2<sup>0</sup> 부터 2<sup>N-1</sup> 까지이다.
* 2<sup>N-1</sup>에 해당하는 비트를 최상위 비트(most significant bit)라고 부르고, 2<sup>0</sup>을 나타내는 비트를 최하위 비트(least significant bit)라고 부른다.
* 어떤 정수를 이진수로 표현했을 때 어떤 비트의 위치가 1이라면 해당 비트가 `켜져 있다`라고 말하고, 0이라면 `꺼져 있다`라고 말한다.



## 비트 연산자

* 비트별 AND 연산은 입력받은 두 정수를 한 비트씩 비교하면서, 두 정수에 해당 비트가 모두 켜져 있을 때만 결과의 비트를 켠다.
* 비트별 OR 연산과 XOR 연산은 AND와 같이 비트별로 동작하지만 OR 연산은 두 비트 중 하나라도 켜져 있을 경우, XOR 연산은 하나는 켜져 있고 하나는 꺼져 있는 경우 결과의 비트를 켠다는 차이점이 있다.
* 비트별 NOT 연산은 정수 하나를 입력받아 켜져 있는 비트는 끄고, 꺼져 있는 비트는 켠 결과를 반환한다.
* 시프트(shift) 연산자는 정수 a의 비트들을 왼쪽 또는 오른쪽으로 원하는 만큼 움직인다.
  * 754(=10 1111 0010<sub>2</sub>)를 왼쪽으로 2비트 시프트하면 모든 비트들이 왼쪽으로 두 칸 움직이고 오른쪽 끝 두 개의 비트들은 0으로 채워진다. 따라서 결과는 3016(=1011 1100 1000<sub>2</sub>)이 된다.
  * 754(=10 1111 0010<sub>2</sub>)를 오른쪽으로 2비트 시프트하면 모든 비트들이 오른쪽으로 두 칸 움직이고 왼쪽 끝 두 개의 비트들은 0으로 채워진다. 따라서 결과는 188(=1011 1100<sub>2</sub>)이 된다.



| 연산                             | 코드   |
| -------------------------------- | ------ |
| 두 정수 a, b를 비트별로 AND 연산 | a & b  |
| 두 정수 a, b를 비트별로 OR 연산  | a \| b |
| 두 정수 a, b를 비트별로 XOR 연산 | a ^ b  |
| 정수 a의 비트별 NOT 연산 결과    | ~a     |
| 정수 a를 왼쪽으로 b비트 시프트   | a << b |
| 정수 a를 오른쪽으로 b비트 시프트 | a >> b |



## 유의할 점들

* 연산자 간 우선순위 혼동

  * C++나 자바에서 &, |, ^ 등의 비트 연산자의 우선순위는 == 혹은 != 등의 비교 연산자보다 낮다.
  * 비트마스크를 사용하는 식에는 가능한 한 괄호를 자세하게 추가하는 습관을 들이는 것이 좋다.

* 64비트 정수를 비트마스크로 사용할 때 발생하는 오버플로우

  ```c++
  bool isBitSet(unsigned long long a, int b) {
      return (a & (1 << b)) > 0;
  }
  ```

  * 부호 없는 64비트 비트마스크 a의 b번 비트가 켜져 있는지 확인하기 위한 코드
  * C++에서 1은 부호 있는 32비트 상수로 취급되기 때문에, b가 32 이상이면 (1 << b) 에서 오버플로우가 발생한다.
  * 1 뒤에 이 상수가 부호 없는 64비트 정수임을 알려주는 접미사 ull을 붙여줘야 한다.

* 부호 있는 정수형 사용

  * 부호 있는 정수형에서 최상위 비트가 켜진 숫자는 음수를 표현한다.
  * 변수의 모든 비트를 다 쓰고 싶을 때는 부호 없는 정수형을 쓰는 것이 좋다.

* C++에서 N비트 정수를 N비트 이상 왼쪽으로 시프트하는 오류

  * 이와 같은 연산의 결과로는 0이 나와야 할 것 같지만, 환경에 따라 다른 결과를 낼 수도 있다.



## 비트마스크를 이용한 집합 구현

* 비트마스크의 가장 중요한 사용 사례는 집합을 구현하는 것이다.
* 이 표현에서 N비트 정수 변수는 0부터 N-1까지의 정수 원소를 가질 수 있는 집합이 된다.
* 원소 i가 집합에 속해 있는지 여부는 2<sup>i</sup>을 나타내는 비트가 켜져 있는지 여부로 나타낸다.
* ex) 여섯 개의 원소를 갖는 집합 {1, 4, 5, 6, 7, 9}를 표현하는 정수는 754이다.
  * 2<sup>1</sup> + 2<sup>4</sup> + 2<sup>5</sup> + 2<sup>6</sup> + 2<sup>7</sup> + 2<sup>9</sup> = 10 1111 0010<sub>2</sub> = 754



### 피자집 예제

* 고객들이 원하는 토핑을 골라 주문할 수 있는 피자집
* 0부터 19까지의 번호를 갖는 스무 가지의 토핑이 있으며, 주문시 토핑을 넣기/넣지 않기를 선택할 수 있다.
* 한 피자의 정보는 스무 종류의 원소만을 가지는 집합이 되고, 비트마스크를 이용해 표현할 수 있다.
* 비트마스크를 이용하면 다양한 비트 연산을 이용해 집합 연산을 빠르고 간단하게 구현할 수 있다.



#### 공집합과 꽉 찬 집합 구하기

* 비트마스크를 이용하는 집합에서는 상수 0이 공집합을 나타낸다.

* 꽉 찬 집합(스무 개의 토핑을 모두 포함하는 집합)은 마지막 20개의 비트가 모두 켜진 숫자이며, 다음과 같은 코드로 얻을 수 있다.

  ```c++
  int fullPizza = (1 << 20) - 1;
  ```

  * 1 << 20은 이진수로 1 뒤에 20개의 0이 있는 정수인데, 여기서 1을 배면 20개의 비트가 모두 켜진 수를 얻을 수 있다.



#### 원소 추가

* 비트마스크를 사용한 집합에서 원소를 추가한다는 것은 해당 비트를 켠다는 것이다.

* 추가하고 싶은 토핑의 번호 p(0 ≤ p < 20)가 주어질 때, 해당 토핑 추가

  ```c++
  toppings |= (1 << p);
  ```

  * 1을 왼쪽으로 p비트 시프트하면 p번 비트만 켜진 정수가 된다. 이 값과 toppings를 비트별 OR 하면 해당 비트는 반드시 켜지게 된다.
  * toppings에 추가하고자 하는 p번 토핑이 이미 들어가 있을 경우 값이 변하지 않는다.



#### 원소의 포함 여부 확인

* 토핑 목록에 p번 토핑이 잘 추가되었는지 확인

  ```c++
  if(toppings & (1 << p)) cout << "p is in" << endl;
  ```

  * & 연산의 결과값이 0 또는 1 << p 이다.
  * 대부분의 논리 연산처럼 원소가 포함되어 있는 경우 1, 혹은 true가 반환된다고 생각하면 실수를 범하게 된다.



#### 원소의 삭제

* p번 토핑을 삭제

  * 1 << p 를 toppings에서 빼는 방법

    ```c++
    toppings -= (1 << p);
    ```

    * 이미 p번 토핑이 토핑 목록에 있을 때만 사용할 수 있다.
    * 만약 p번 토핑이 없는데 이런 방법을 사용하면 큰일난다.

  * p번 토핑이 없을 때도 정상적으로 동작하는 방법

    ```c++
    toppings &= ~(1 << p);
    ```

    * C++의 ~ 연산자는 비트별 NOT 연산을 수행하므로, ~(1 << p) 는 해당 비트만 꺼지고 나머지는 다 켜진 숫자가 된다. 이 숫자와 비트별 AND 연산을 수행하면 toppings의 나머지 비트는 유지되고 p번 비트는 항상 꺼지게 된다.



#### 원소의 토글

* 토글(toggle) : 해당 비트가 켜져 있으면 끄고, 꺼져 있으면 켜는 것

* XOR 연산이 이와 같은 일을 한다.

  ```c++
  toppings ^= (1 << p);
  ```

  

#### 두 집합에 대해 연산하기

* 두 개의 토핑 집합 a와 b의 합집합과 차집합 등을 다음과 같이 구할 수 있다.

  ```c++
  int added = (a | b);			// a와 b의 합집합
  int intersection = (a & b);		// a와 b의 교집합
  int removed = (a & ~b);			// a에서 b를 뺀 차집합
  int toggled = (a ^ b);			// a와 b중 하나에만 포함된 원소들의 집합
  ```

  * 이 코드의 수행 시간은 원소 하나에 대해 수행하는 것과 다를 게 없다.



#### 집합의 크기 구하기

* 가장 간단한 방법은 각 비트를 순회하면서 켜져 있는 비트의 수를 직접 세는 수밖에 없다.

* 재귀 호출로 작성

  ```c++
  int bitCount(int x) {
      if(x == 0) return 0;
      return x % 2 + bitCount(x / 2);
  }
  ```

  

#### 최소 원소 찾기

* 최하위 비트의 번호 대신 해당 비트를 직접 구하기

* ex) 40이 주어질 경우 3 대신 2<sup>3</sup>을 구한다.

  ```c++
  int firstTopping = (toppings & -toppings);
  ```

  * 대부분의 컴퓨터가 음수를 표현하기 위해 2의 보수를 사용한다는 점을 이용
  * 2의 보수를 사용하는 시스템에서 음수 -toppings를 표현하기 위해서 toppings에 비트별 NOT 연산을 적용하고 그 결과에 1을 더한다.
  * toppings에서 켜진 최하위 비트가 2<sup>i</sup>라고 하면, toppings의 마지막 i + 1자리는 1 뒤에 i개의 0이 있는 형태여야 한다.
  * toppings에 비트별 NOT 연산을 적용하면 마지막 i + 1자리는 0뒤에 i개의 1이 있는 형태가 되고, 여기에 1을 더하면 다시 1과 i개의 0이 있는 형태가 된다.
  * 2<sup>i</sup>보다 상위 비트들에는 NOT 연산이 적용된 상태이므로 두 수를 AND 하면 항상 최하위 비트만을 얻을 수 있다.



#### 최소 원소 지우기

* 최소 원소를 지우는 코드

  ```c++
  toppings &= (toppings - 1);
  ```

  * toppings - 1의 이진수 표현은 toppings에서 켜져 있는 최하위 비트를 끄고 그 밑의 비트들을 전부 켠 것이다.
  * 따라서 두 값을 비트별 AND 연산하면 최하위 비트와 그 이하의 비트들은 전부 0이 된다.
  * 어떤 정수가 2의 거듭제곱 값인지 확인할 때도 유용하게 쓰인다. 2의 거듭제곱 값들의 이진수 표현에는 켜진 비트가 하나밖에 없기 때문에, 최하위 비트를 지웠을 때 0이 된다면 주어진 수는 2의 거듭제곱이다.



#### 모든 부분 집합 순회하기

* 주어진 집합의 모든 부분 집합을 순회하기

  ```c++
  for (int subset = pizza; subset; subset = ((subset - 1) & pizza)) {
      // subset은 pizza의 부분집합
  }
  ```

  * 다음 부분 집합을 구하는 식 : (subset - 1) & pizza
  * subset에서 1을 빼면 켜져 있던 최하위 비트가 꺼지고, 그 밑의 비트들은 전부 켜지게 된다.
  * 이 결과와 pizza의 교집합을 구하면 그 중 pizza에 속하지 않는 비트들은 모두 꺼지게 된다.
  * 이 연산을 반복하면 pizza의 모든 부분 집합을 방문할 수 있다.
  * for문은 subset == 0인 시점에서 종료하므로 공집합은 방문하지 않는다.



