# 유니온 파인드(Union-Find)

## 유니온 파인드(Union-Find)

* 상호 배타적 집합(Disjoint Set)
* 공통 원소가 없는, 다시 말해 상호 배타적인 부분 집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조
* 다음과 같은 3가지 연산 필요
  * 초기화 : n개의 원소가 각각의 집합에 포함되어 있도록 초기화
  * 합치기(union) 연산 : 두 원소 a, b가 주어질 때 이들이 속한 두 집합을 하나로 합친다.
  * 찾기(find) 연산 : 어떤 원소 a가 주어질 때 이 원소가 속한 집합을 반환
* 합치기(union), 찾기(find)의 두 연산을 지원한다고 해서 이 자료 구조를 유니온-파인드(union-find) 자료구조라고 부른다.



## 트리를 이용한 상호 배타적 집합의 표현

* 한 집합에 속하는 원소들을 하나의 트리로 묶는다.
* 상호 배타적 집합 자료 구조는 트리들의 집합으로 표현된다.
* 두 원소가 같은 트리에 속해 있는지 확인하는 가장 직관적인 방법은 각 원소가 포함된 트리의 루트를 찾은 뒤 이들이 같은지 비교하는 것이다.
* 찾기 연산은 주어진 원소가 포함된 트리의 루트를 찾는 것으로 구현된다.
* 찾기 연산을 구현하기 위해서는 모든 자식 노드가 부모에 대한 포인터를 가지고 있어야 한다.
* 루트는 부모가 없으므로, 대개 자기 자신을 가리키도록 구현한다.
* 두 원소가 포함된 집합을 합치는 방법은 각 트리의 루트를 찾은 뒤, 하나를 다른 한쪽의 자손으로 넣으면 된다.

```c++
/* 트리를 이용한 상호 배타적 집합 자료 구조의 구현 */
// 트리를 이용해 상호 배타적 집합을 구현한다.
struct NaiveDisjointSet{
    vector<int> parant;
    NaiveDisjointSet(int n): parent(n) {
        for(int i = 0; i < n; ++i)
            parent[i] = i;
    }
    // u가 속한 트리의 루트의 번호를 반환한다.
    int find(int u) const {
        if(u == parent[u]) return u;
        return find(parent[u]);
    }
    // u가 속한 트리와 v가 속한 트리를 합친다.
    void merge(int u, int v) {
        u = find(u); v = find(v);
        // u와 v가 이미 같은 트리에 속하는 경우를 걸러낸다.
        if(u == v) return;
        parnet[u] = v;
    }
};
```

* 각 노드들을 객체로 표현하는 대신에, 자신의 부모의 번호를 저장하는 1차원 배열만으로 표현
* find() 함수를 실행하는 데 해당 트리의 높이에 비례하는 시간이 걸린다. (merge() 함수의 수행 시간도 마찬가지)
* 트리가 한 쪽으로 기울어지면 탐색 효율이 나빠진다.



## 상호 배타적 집합의 최적화

* 두 트리를 합칠 때 항상 높이가 더 낮은 트리를 더 높은 트리 밑에 집어넣음으로써 트리의 높이가 높아지는 상황을 방지
* 랭크에 의한 합치기(union-by-rank) 최적화

```c++
/* 최적화된 상호 배타적 집합의 구현 */
// 트리를 이용해 상호 배타적 집합을 구현
struct OptimizedDisjointSet {
    vector<int> parent, rank;
    OptimizedDisjointSet(int n) : parent(n), rank(n, 1) {
        for(int i = 0; i < n; ++i)
            parent[i] = i;
    }
    // u가 속한 트리의 루트의 번호를 반환
    int find(int u) {
        if(u == parent[u]) return u;
        return parent[u] = find(parent[u]);
    }
    // u가 속한 트리와 v가 속한 트리를 합친다.
    void merge(int u, int v) {
        u = find(u); v = find(v);
        // u와 v가 이미 같은 집합에 속하는 경우를 걸러낸다.
        if(u == v) return;
        if(rank[u] > rank[v]) swap(u, v);
        // 이제 rank[v]가 항상 rank[u] 이상이므로 u를 v의 자식으로 넣는다.
        parent[u] = v;
        if(rank[u] == rank[v]) ++rank[v];
    }
};
```

* rank[]는 해당 노드가 한 트리의 루트인 경우 해당 트리의 높이를 저장한다.
* 두 노드를 합칠 때 높이를 비교해서 낮은 쪽을 높은 트리의 서브트리로  포함
* 두 트리의 높이가 같은 경우에만 결과 트리의 높이를 1 늘려준다.
* 합치기 연산과 찾기 연산의 시간복잡도는 O(N)이 아니라 O(lgN)이 된다.
* 경로 압축 최적화



## 그래프의 연결성 확인하기

* 크루스칼의 최소 스패닝 트리 알고리즘



## 가장 큰 집합 추적하기

* 각 집합에 속한 원소의 수를 추적할 수 있다.
* 각 트리의 노드의 개수를 담는 배열 size[]를 추가한 뒤 두 집합이 합쳐질 때마다 이 값을 갱신



